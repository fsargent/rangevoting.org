<html>
<head>
<title>
RangeVoting.org - Tetrud's multiwinner voting method BR simulator
</title>
</head>
<body style="font-family: Arial, sans-serif">
<h2>
Tetrud's multiwinner voting method BR simulator
</h2>
<p>
This page contains code (about 900 lines of javascript)
for simulating multiwinner elections as described 
<a href="BRmulti.html">here</a> using
"multiwinner Bayesian Regret, 2-stage methodology."
Only the simplest possible variant of everything 
is presently implemented
&ndash; random numbers as utilities, all candidates 
and voters honest,
and only one "chunk."
Also, only comparatively simple
voting methods have been implemented &ndash;
ones that were too hard to code, debug, or too slow,
being left for later.
Also, it is not made obvious via some sort of 
documentation,
exactly what each voting method really is.
Be nice to have a user-input form so you can choose
certain parameters to explore,
e.g.
<blockquote>
<ol><li>
Number of voters
</li><li>
Number of candidates
</li><li>
Number of winners (i.e. of seats)
</li><li>
Number of societal-option "chunks"
</li><li>
Number of societal-options
</li><li>
Number of "districts" country is divided into
</li><li>
Which single-winner voting method is used in 
"second stage"
</li><li>
Which utility generator to use
</li><li>
Which voter-behavior (or mixture of behaviors) to use
</li><li>
Which candidate behavior to use
</li><ol>
</blockquote>
then it does it &ndash; but no such form at present.
You have to click "view source" in your browser
to see the underlying
javascript code.
Otherwise (if you have javascript enabled)
your browser should now be <i>running</i> the code 
then printing out
the results at the end of this page, which might 
take 100 seconds or whatever.
The numbers it prints are the <i>reciprocals</i> of 
Bayesian Regrets,
i.e, better voting methods have greater numbers.
At present, the best method among those implemented
seems to be
<a href="RRV.html">reweighted range voting</a> 
with 3-member parliament?
(Well, not always, it varies from run to run?)
</p><p>
This code was 
written by Billy Tetrud, a programmer in the CA bay area.
It has not been checked nor even fully understood by me
(Warren D. Smith)
as yet, but I am just reposting it here for storage purposes 
(version of 13 Nov 2016).
It looks like a good start, I'll say that much.
</p><p>
<b>Update:</b>
Tetrud has posted a 
more-recent and more-documented version of
his javascript code on
github:
<a href=" https://github.com/fresheneesz/elect">
 https://github.com/fresheneesz/elect
</a>
</p><p>
And if this work is continued then we will start 
to turn government design
into more of a science and less of a black art.
(For example: what is the optimum size for a parliament?)
Tetrud has a blog at 
<a href="https://rangevoting.org/governology.wordpress.com">
governology.wordpress.com</a>.
</p>
<hr>
<div id='results'></div>



<script>
function main() {
    //var numberOfCandidates = 10, numberOfVoters = 100, numberOfSocietalOptions = 100, iterations = 100
    var numberOfCandidates = 30, numberOfVoters = 10, numberOfSocietalOptions = 10, iterations = 2500

    // For each system:
    // algorithm
        // takes in an array of votes where each vote is the output of a given `strategy` for the system
        // returns an object where each key is a winner, and each value is an object with the properties:
            // weight - the winner's vote weight
            // preferences - the winner's voting preferences for each societal option
    // each strategy:
        // returns a "vote", a set of data used by votingSystem to determine winners
    var votingSystems = {
        Random: {
            algorithms: {
                '':function(votes, candidates) {
                    var winner = Math.round(random()*(candidates.length-1))
                    return [{index: winner, weight:1, preferences:candidates[winner]}]
                }
            },
            strategies: {
                noname:function() {
                    // strategies don't matter for this one
                }
            }
        },
        'Random Voter\'s Choice': {
            algorithms: {
                '':function(votes, candidates) {
                    var luckyWinnerIndex = Math.round(random()*(votes.length-1))
                    var luckyWinnerVote = votes[luckyWinnerIndex]
                    return [{index: luckyWinnerVote, weight:1, preferences:candidates[luckyWinnerVote]}]
                }
            },
            strategies: {
                Honest: honestTopChoice
            }
        },
        'Random 10-Percent Voter\'s Choice': {
            algorithms: {
                '':function(votes, candidates) {
                    var luckyVotes = []
                    while(luckyVotes.length < votes.length*.1) {
                        var luckyWinnerIndex = Math.round(random()*(votes.length-1))
                        luckyVotes.push(votes[luckyWinnerIndex])
                    }

                    return pluralityAlg(luckyVotes, candidates)
                }
            },
            strategies: {
                Honest: honestTopChoice
            }
        },
        Plurality: {
            algorithms: {
                '':pluralityAlg
            },
            strategies: {
                Honest: honestTopChoice
            }
        },
        Range: {
            algorithms: {
                '':function(votes, candidates) {
                    var results = []
                    for(var n=0; n<candidates.length;n++) {
                        results[n] = 0
                    }

                    votes.forEach(function(vote){
                        vote.forEach(function(value, index) {
                            results[index] += value
                        })
                    })

                    var transformedResults = results.map(function(value,index){
                        return {candidate:index,votes:value}
                    })

                    transformedResults.sort(function(a,b) {
                        return b.votes - a.votes // reverse sort
                    })

                    var winner = transformedResults[0].candidate
                    return [{index: winner, weight:1, preferences:candidates[winner]}]
                }
            },
            strategies: {
                'Honest Exact': rangeStrategy_honestExact,
                'Honest Nearest-1-through-5': rangeStrategy_honestNearest1to5
            }
        },
        'Range 3 Winners': {
            algorithms: {
                '':function(votes, candidates) {
                    var results = []
                    for(var n=0; n<candidates.length;n++) {
                        results[n] = 0
                    }

                    votes.forEach(function(vote){
                        vote.forEach(function(value, index) {
                            results[index] += value
                        })
                    })

                    var transformedResults = results.map(function(value,index){
                        return {candidate:index,votes:value}
                    })

                    transformedResults.sort(function(a,b) {
                        return b.votes - a.votes // reverse sort (most votes foist)
                    })

                    var winners = [], totalScore = 0
                    for(var n=0; n<3; n++) {
                        var winnerIndex = transformedResults[n].candidate
                        var winner = candidates[winnerIndex]
                        winners.push({index: winnerIndex, preferences:winner})
                        totalScore+= transformedResults[n].votes
                    }

                    winners.forEach(function(winner, index) {
                        winner.weight = transformedResults[index].votes/totalScore
                    })

                    return winners
                }
            },
            strategies: {
                'Honest Exact': rangeStrategy_honestExact,
                'Honest Nearest-1-through-5': rangeStrategy_honestNearest1to5
            }
        },
        'Single-Transferable Vote': {
            algorithms: {
                '1 winner':singleTransferrableVote(1),
                '3 winner':singleTransferrableVote(3)
            },
            strategies: {
                Honest: rankedVote_honest
            }
        },
        'Direct Representative Ranked, 15-Percent Threshold': {
            algorithms: {'':fractionalRepresentativeRankedVote(.15)}, // 15% minimum
            strategies: {
                Honest: rankedVote_honest
            }
        },
        'Direct Representative Range': {
            algorithms: {
                'split-weight, no max winners, 0% threshold': directRepresentationRange('normal', 'split', Infinity,0),
                'highest-weight, max 3 winners, 20% threshold': directRepresentationRange('normal', 'highest', 3,.5),
                'split-weight, max 3 winners, 20% threshold': directRepresentationRange('normal', 'split', 3,.9),
                'equal-weight, max 3 winners, 20% threshold': directRepresentationRange('normal', 'equal', 3,.9),
                'highest-weight, minority-max, max 3 winners, 20% threshold': directRepresentationRange('maxMinority', 'highest', 3,.9),
                'split-weight, minority-max, max 3 winners, 20% threshold': directRepresentationRange('maxMinority', 'split', 3,.9),
                'equal-weight, minority-max, max 3 winners, 20% threshold': directRepresentationRange('maxMinority', 'equal', 3,.9),
                'highest-weight, <b>reweighted</b>': directRepresentationRange('reweighted', 'highest', 3,0),
                'split-weight, <b>reweighted</b>, 3 winners': directRepresentationRange('reweighted', 'split', 3,0),
                'equal-weight, <b>reweighted</b>, 3 winners': directRepresentationRange('reweighted', 'equal', 3,0),
            },
            strategies: {
                'Honest Exact': rangeStrategy_honestExact,
                'Honest Nearest-1-through-5': rangeStrategy_honestNearest1to5
            }
        },
    }


    testSystems(votingSystems, numberOfSocietalOptions, numberOfCandidates, numberOfVoters, iterations)

}

    function testSystems(systems, numberOfSocietalOptions, numberOfCandidates, numberOfVoters, iterations) {
        var knobsOutput = '<div>Societal Options: '+numberOfSocietalOptions+'</div>'+
                          '<div>Candidates: '+numberOfCandidates+'</div>'+
                          '<div>Voters: '+numberOfVoters+'</div>'+
                          '<div>Iterations: '+iterations+'</div>'+
                          '<br>'

        var n=1, totalRegretFractionSumPerSystem = {}, totalWinnersPerSystem = {}
        function iteration(complete) {
            var election = Election(numberOfVoters, numberOfCandidates, numberOfSocietalOptions)

            for(var systemName in systems) {
                var system = systems[systemName]
                for(var strategyName in system.strategies) {
                    var strategy = system.strategies[strategyName]
                    for(var algorithmName in system.algorithms) {
                        var systemStrategyName = getVotingTypeName(systemName, strategyName, algorithmName)

                        var winners = election.elect(system.algorithms[algorithmName], strategy, election.voters, election.candidates)
                        var regretFraction = election.regretFraction(election.voters, winners)

                        if(totalRegretFractionSumPerSystem[systemStrategyName] === undefined) {
                            totalRegretFractionSumPerSystem[systemStrategyName] = 0
                            totalWinnersPerSystem[systemStrategyName] = 0
                        }

                        totalRegretFractionSumPerSystem[systemStrategyName] += regretFraction
                        totalWinnersPerSystem[systemStrategyName] += winners.length
                    }
                }
            }

            resultsDiv.innerHTML = knobsOutput+'Completion: '+Number(100*n/iterations).toPrecision(3)+'%'
            setTimeout(function() {
                if(n<iterations) {
                    iteration(complete)
                    n++
                } else {
                    complete()
                }
            })
        }

        var resultsDiv = document.getElementById('results')
        iteration(function() {
            var content = knobsOutput+
                          '<div><b>Voter Satisfaction Averages (inverse of Bayesian Regret):</b></div>'+
                          '<table>'

            Object.keys(totalRegretFractionSumPerSystem).map(function(name) {
                return {name:name, totalRegret:totalRegretFractionSumPerSystem[name]}
            }).sort(function(a,b) {
                return a.totalRegret - b.totalRegret
            }).forEach(function(votingType) {
                var systemStrategyName = votingType.name
                var totalRegret = votingType.totalRegret

                var averageRegretFraction = totalRegret/n
                var avgWinners = totalWinnersPerSystem[systemStrategyName]/n

                var displayAverage = Number(100*(1-averageRegretFraction)).toPrecision(2)
                content += '<tr><td style="text-align:right;">'+systemStrategyName+"</td><td><b>"+displayAverage+'%</b> with avg of '+avgWinners+' winners</td></tr>'
            })

            content+= '</table>'
            resultsDiv.innerHTML = content
        })
    }




function honestTopChoice(voter, voterIndex, election) {
    var curBestCandidate, curBestUtility
    election.voterCandidateUtilities[voterIndex].forEach(function(utility, n) {
        if(curBestUtility === undefined || utility > curBestUtility) {
            curBestCandidate = n
            curBestUtility = utility
        }
    })

    return curBestCandidate
}

// piegeonHoleFunction() - a function that takes in a number and returns a number potentially rounded in some way
function rangePigeonHoleStrategy(piegeonHoleFunction) {
    return function(voter, voterIndex, election) {
        // the maximum utility that the best dictator-candidate would give for this voter
        var maxUtility = Math.max.apply(null, election.voterCandidateUtilities[voterIndex])
        var minUtility = Math.min.apply(null, election.voterCandidateUtilities[voterIndex])

        return election.voterCandidateUtilities[voterIndex].map(function(utility) {
            return piegeonHoleFunction(utility, maxUtility, minUtility)
        })
    }
}

// gives votes between -1 and 1
var rangeStrategy_honestExact = rangePigeonHoleStrategy(function(utility, maxUtility, minUtility) {
    if(maxUtility === minUtility) { // this branch prevents a divide by 0 error
        return 0
    } else {
        var utilityFraction = (utility-minUtility)/(maxUtility-minUtility)
        return utilityFraction
    }
})

// gives votes between -1 and 1
var rangeStrategy_honestNearest1to5 = rangePigeonHoleStrategy(function(utility, maxUtility, minUtility) {
    if(maxUtility === minUtility) { // this branch prevents a divide by 0 error
        return 3
    } else {
        var utilityFraction = (utility-minUtility)/(maxUtility-minUtility)
        return Math.round(5*utilityFraction)/5
    }
})

var rankedVote_honest = function(voter, voterIndex, election) {
    var preferences = election.voterCandidateUtilities[voterIndex]
    var order = preferences.map(function(candidateUtility, index) {
        return {utility: candidateUtility, index:index}
    }).sort(function(a,b) {
        return b.utility-a.utility // highest to lowest
    })

    return order.map(function(x) {
        return x.index
    })
}

var pluralityAlg = function(votes, candidates) {
    var results = []
    for(var n=0; n<candidates.length;n++) {
        results[n] = 0
    }

    votes.forEach(function(vote) {
        results[vote]++
    })

    var sortedTransformedResults = results.map(function(value,index){
        return {candidate:index,votes:value}
    }).sort(function(a,b) {
        return b.votes - a.votes // reverse sort
    })

    var winner = sortedTransformedResults[0].candidate
    return [{index: winner, weight:1, preferences:candidates[winner]}]
}




// countType can either be "normal" or "maxMinority"
    // normal is where the winners are the x candidates with the greatest total score
    // maxMinority is where each successive winner is chosen from only the votes of those who haven't chosen a winner as their top choice
    // reweighted is for a reweighted range vote described here; /RRV.html
// winnerWeightType can either be "highest" or "split"
    // "highest" means winner vote weight will be the sum of the number of voters who gave that winner the higest score
    // "split" means winner vote weight is the sum of all votes
    // "equal" means each winner gets an equal vote weight
// minThreshold is a number from 0 to 1 representing the ratio of average score to the average score of the highest scoring candidate
    // note that the votes are shifted so that they're a range from 0 to 2 for the purposes of calculating this
function directRepresentationRange(countType, winnerWeightType, maxWinners, minThreshold) {
    return function(votes, candidates) {

        var winners = {}, disqualified = {}

        var countedVotes = countVotes(candidates, votes, winners, disqualified)
        var nextWinner = findNextWinner(countedVotes)
        var highestAvgScore = getAvgScore(countedVotes[nextWinner])

        countedVotes.forEach(function(info, candidate) {
            var avgScore = getAvgScore(info)
            if(avgScore < highestAvgScore*minThreshold) {
                disqualified[candidate] = true
            }
        })

        winners[nextWinner] = true

        while(Object.keys(winners).length < maxWinners && Object.keys(winners).length+Object.keys(disqualified).length < candidates.length) {
            var nextWinnerCountedVotes = countVotes(candidates, votes, winners, disqualified, countType)

            var nextWinner = findNextWinner(nextWinnerCountedVotes)
            winners[nextWinner] = true
        }

        if(winnerWeightType === 'highest') {
            var results = []
            var resultsMap = {} //maps a winner to a result index
            for(var winner in winners) {
                resultsMap[winner] = results.length
                results.push({index:winner, weight:0, preferences:candidates[winner]})
            }

            votes.forEach(function(vote) {
                var highestWinners = {}, highestWinnerScore = -Infinity
                vote.forEach(function(score, candidateIndex) {
                    if(candidateIndex in winners) {
                        if(score > highestWinnerScore) {
                            highestWinners = {}
                            highestWinners[candidateIndex] = true
                            highestWinnerScore = score
                        } else if(score === highestWinnerScore) {
                            highestWinners[candidateIndex] = true
                        }
                    }
                })

                var numberOfHighestWinners = Object.keys(highestWinners).length
                for(var winner in highestWinners) {
                    results[resultsMap[winner]].weight += 1/numberOfHighestWinners
                }
            })
        } else if(winnerWeightType === 'split') {
            var results = []
            for(var winner in winners) {
                var avgScore = countedVotes[winner].totalScore/countedVotes[winner].totalNumber
                results.push({index:winner, weight:avgScore, preferences:candidates[winner]})
            }
        } else if(winnerWeightType === 'equal') {
            var results = []
            for(var winner in winners) {
                results.push({index:winner, weight:1, preferences:candidates[winner]})
            }
        }

        return results
    }

    function getAvgScore(candidateInfo) {
        return candidateInfo.totalScore/candidateInfo.totalNumber
    }

    function findNextWinner(countedVotes) {
        var nextWinner, curWinnerScore = -Infinity
        countedVotes.forEach(function(info, candidate) {
            if(info.totalScore > curWinnerScore) {
                nextWinner = candidate
                curWinnerScore = info.totalScore
            }
        })

        return nextWinner
    }

    function countVotes(candidates, votes, winners, disqualified, countType) {
        if(winners === undefined) winners = {}
        var countedVotes = candidates.map(function(p,c){
            if(!(c in winners) && !(c in disqualified)) {
                return {totalScore:0, totalNumber:0}
            } else {
                return {totalScore:-Infinity, totalNumber:0}
            }
        })
        votes.forEach(function(vote) {
            if(countType === 'maxMinority') {
                var highestCandidates = {}, highestScore = -Infinity
                vote.forEach(function(score, candidateIndex) {
                    if(score > highestScore) {
                        highestCandidates = {}
                        highestCandidates[candidateIndex] = true
                        highestScore = score
                    } else if(score === highestScore) {
                        highestCandidates[candidateIndex] = true
                    }
                })

                for(var c in highestCandidates) {  // only count votes for people who's highest choice isn't a winner
                    if(c in winners) {
                        return; // continue
                    }
                }
            } else if(countType === 'reweighted') {
                var sumScoreForWinners = 0
                vote.forEach(function(score, candidateIndex) {
                    if(candidateIndex in winners) {
                        sumScoreForWinners += score
                    }
                })

                var weight = 1/(1+sumScoreForWinners/2)
            }

            vote.forEach(function(score, candidateIndex) {
                if(!(candidateIndex in disqualified)) {
                    var hasntChosenAWinner = !(candidateIndex in winners)
                    if(countType === 'reweighted') {
                        countedVotes[candidateIndex].totalScore += score*weight
                        countedVotes[candidateIndex].totalNumber ++
                    } else if(countType !== 'maxMinority' || hasntChosenAWinner) {  // only count votes for new potential winners
                        countedVotes[candidateIndex].totalScore += score
                        countedVotes[candidateIndex].totalNumber ++
                    }
                }
            })
        })
        return countedVotes
    }
}

// threshold - a number between 0 and 1 inclusive
var fractionalRepresentativeRankedVote = function(threshold) {
    return function(votes, candidates) {
        var minimumWinningVotes = votes.length*threshold
        var originalVotes = votes

        var currentWinners = {}, countedVotes = candidates.map(function(){return 0})
        votes.forEach(function(vote) {
            var candidateIndex = vote[0]
            countedVotes[candidateIndex] ++
        })

        // select initial winners
        for(var candidateIndex in countedVotes) {
            var votesForThisCandidate = countedVotes[candidateIndex]
            if(votesForThisCandidate >= minimumWinningVotes) {
                currentWinners[candidateIndex] = true
            }
        }

        // remove votes of those who have chosen a winner
        votes = votes.filter(function(vote) {
            return !(vote[0] in currentWinners)
        })

        // iterate through preferences to find more winners
        for(var currentPreferenceIndex = 1; currentPreferenceIndex<candidates.length; currentPreferenceIndex++) {
            votes.forEach(function(vote) {
                var candidateIndex = vote[currentPreferenceIndex]
                countedVotes[candidateIndex] ++
            })

            // if there are any winners combining preferences 0 through n, choose best winner who isn't already a winner
            var leadingNonWinner, leadingNonWinnerVotes = 0
            for(var candidateIndex in countedVotes) {
                var votesForThisCandidate = countedVotes[candidateIndex]
                if(votesForThisCandidate >= minimumWinningVotes) {
                    if(!(candidateIndex in currentWinners) && votesForThisCandidate > leadingNonWinnerVotes) {
                        leadingNonWinner = candidateIndex
                        leadingNonWinnerVotes = votesForThisCandidate
                    }
                }
            }

            if(leadingNonWinner !== undefined) {
                currentWinners[leadingNonWinner] = true
            }

            // redact votes by voters who have chosen a winner from non-winners they previously chose
            votes.forEach(function(vote) {
                var curCandidateIndex = vote[currentPreferenceIndex]
                if(curCandidateIndex in currentWinners) {
                    for(var n=0; n<currentPreferenceIndex; n++) {
                        var candidatePreferenceIndex = vote[n]
                        countedVotes[candidatePreferenceIndex] --
                    }
                }
            })

            // remove votes of those who have just chosen a winner
            votes = votes.filter(function(vote) {
                return !(vote[currentPreferenceIndex] in currentWinners)
            })
        }

        // this needs to happen because its possible for a vote to be counted for an earlier winner,
        // when the vote's preference is for a winner that was chosen in a later round
        var winnersRecount = candidates.map(function(){return 0})
        originalVotes.forEach(function(vote) {
            for(var n=0;n<vote.length;n++) {
                if(vote[n] in currentWinners) {
                    winnersRecount[vote[n]] ++
                    break;
                }
            }
        })

        var finalWinners = []
        for(var candidateIndex in currentWinners) {
            var votesForThisCandidate = winnersRecount[candidateIndex]
            finalWinners.push({index: candidateIndex, weight:votesForThisCandidate/originalVotes.length, preferences:candidates[candidateIndex]})
        }

        return finalWinners
    }
}

var singleTransferrableVote = function(seats) {
    return function(votes, candidates) {
        var voteQuota = 1+votes.length/(seats+1)

        var newVotesMap = function() {
            var votesList = {}
            candidates.forEach(function(candidate, index){
                votesList[index] = {currentVotes: [], currentCount:0}
            })

            return votesList
        }

        var countedVotes = newVotesMap(), currentWinners = {}, eliminatedCandidates = {}
        votes.forEach(function(vote) {
            var candidate = countedVotes[vote[0]]
            candidate.currentVotes.push({vote:vote, weight:1, currentPreferenceIndex:0})
            candidate.currentCount ++
        })

        var transferVotes = function(transferOrigin, transferDestination, ratioToTransfer) {
            transferOrigin.currentVotes.forEach(function(voteInfo) {
                var newCandidatePreference = voteInfo.currentPreferenceIndex +1
                while(true) {
                    var nextCandidatePreference = voteInfo.vote[newCandidatePreference]
                    if(nextCandidatePreference in eliminatedCandidates || nextCandidatePreference in currentWinners) {
                        newCandidatePreference ++
                    } else {
                        break
                    }
                }

                var candidateIndex = voteInfo.vote[newCandidatePreference]
                if(candidateIndex !== undefined) {
                    transferDestination[candidateIndex].currentVotes.push({        // transfer the excess
                        vote:voteInfo.vote,
                        weight:voteInfo.weight*ratioToTransfer,
                        currentPreferenceIndex:newCandidatePreference
                    })
                    transferDestination[candidateIndex].currentCount += voteInfo.weight*ratioToTransfer
                }

                //transferOrigin.currentCount -= voteInfo.weight*ratioToTransfer // just for testing // todo: comment this out
                voteInfo.weight *= (1-ratioToTransfer) // keep the remainder
            })
        }

        while(true) {
            var votesInTranfer = newVotesMap()
            while(true) {
                var excessFound = false
                for(var candidateIndex in countedVotes) {
                    var votes = countedVotes[candidateIndex].currentCount
                    if(votes >= voteQuota - .01) {
                        currentWinners[candidateIndex] = true
                        if(votes > voteQuota) {
                            excessFound = true
                            var excessVotes = votes - voteQuota
                            var excessRatio = excessVotes/votes

                            transferVotes(countedVotes[candidateIndex], votesInTranfer, excessRatio)

                            // When testing, ensure that countedVotes[candidateIndex].currentCount already is equal to voteQuota when testing line A is uncommented
                            countedVotes[candidateIndex].currentCount = voteQuota
                        }
                    }
                }

                if(!excessFound) {
                    break
                } else {
                    for(var candidateIndex in votesInTranfer) {
                        var newVotes = votesInTranfer[candidateIndex]
                        newVotes.currentVotes.forEach(function(vote) {
                            countedVotes[candidateIndex].currentVotes.push(vote)
                        })

                        if(newVotes.currentCount > 0)
                            countedVotes[candidateIndex].currentCount += newVotes.currentCount
                    }

                    votesInTranfer = newVotesMap()
                }
            }

            if(Object.keys(currentWinners).length < seats) {
                // find candidate with least votes
                var candidateWithLeastCount=undefined, lowestCount=undefined
                for(var candidateIndex in countedVotes) {
                    var candidate = countedVotes[candidateIndex]
                    if(lowestCount === undefined || candidate.currentCount < lowestCount) {
                        lowestCount = candidate.currentCount
                        candidateWithLeastCount = candidateIndex
                    }
                }

                eliminatedCandidates[candidateWithLeastCount] = true

                // transfer votes from that candidate
                transferVotes(countedVotes[candidateWithLeastCount], countedVotes, 1)

                if(Object.keys(countedVotes).length === 1) { // if there's only one candidate left, make them a winner even tho they didn't reach the quota
                    currentWinners[candidateWithLeastCount] = true
                    break
                } else {
                    // eliminate the candidate
                    delete countedVotes[candidateWithLeastCount]
                }
            } else {
                break
            }
        }

        var finalWinners = []
        for(var candidateIndex in currentWinners) {
            finalWinners.push({index: candidateIndex, weight:1, preferences:candidates[candidateIndex]})
        }

        return finalWinners
    }
}

// proto v1.0.19
!function(r,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):"object"==typeof exports?exports.proto=e():r.proto=e()}(this,function(){return function(r){function e(t){if(n[t])return n[t].exports;var o=n[t]={exports:{},id:t,loaded:!1};return r[t].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=r,e.c=n,e.p="",e(0)}([function(r){"use strict";function e(){var r=arguments;if(1==r.length)var p={init:i},s=r[0];else var p=r[0],s=r[1];var v={};-1!==[Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError].indexOf(p)&&(p=n(p,v));var y="function"==typeof p;s[a]=y?p[a]:p;var d=new s(p);v.name=d.name,!d[c]&&y&&(d[c]=function(){p.apply(this,arguments)});var l=function(){};l[a]=d;var m=d.name?d.name:"";if(d[c]===o||d[c]===i)var x=new Function("F","return function "+m+"(){return new F()}")(l);else var x=new Function("F","i","u","n","return function "+m+"(){ var x=new F(),r=i.apply(x,arguments)\nif(r===n)\nreturn x\nelse if(r===u)\nreturn n\nelse\nreturn r\n}")(l,d[c],e[u]);d.constructor=x;for(var g in d)t(x,d,g);for(var g in p)f.call(p,g)&&x[g]===o&&t(x,p,g);return x.parent=p,x[a]=d,x}function n(r,e){function n(){var n=new r(arguments[0]);return n.name=e.name,this.message=n.message,Object.defineProperty?Object.defineProperty(this,"stack",{get:function(){return n.stack},configurable:!0}):this.stack=n.stack,this}var t=function(){};return t.prototype=r.prototype,n.prototype=new t,n}function t(r,e,n){try{var t=Object.getOwnPropertyDescriptor(e,n);t.get!==o||t.get!==o&&Object.defineProperty!==o?Object.defineProperty(r,n,t):r[n]=e[n]}catch(i){}}var o,i=function(){},a="prototype",u="undefined",c="init",f={}.hasOwnProperty;e[u]={},r.exports=e}])});
//# sourceMappingURL=proto.umd

var Election = proto(function() {
    this.init = function(numberOfVoters, numberOfCandidates, numberOfSocietalOptions) {

//        var voterOptionModifiers = [], candidateOptionModifiers = [] // these make the random candidates and voters much more varied
//        for(var j=0; j<numberOfSocietalOptions; j++) {
//            voterOptionModifiers[j] = createModifier()
//            candidateOptionModifiers[j] = createModifier()
//        }

        var voters = [], candidates = []
        for(var j=0;j<numberOfVoters;j++) {
            voters.push(generatePerson(numberOfSocietalOptions))
        }
        for(var j=0;j<numberOfCandidates;j++) {
            candidates.push(generatePerson(numberOfSocietalOptions))
        }

        var netUtilities = findNetUtilities(voters)
        var optimalOutcomes = netUtilities.map(function(optionUtility) {
            return optionUtility > 0
        })
        var leastOptimalOutcomes = optimalOutcomes.map(function(outcome) {
            return !outcome
        })

        this.maxUtility = totalOutcomeUtility(voters, optimalOutcomes)
        this.minUtility = totalOutcomeUtility(voters, leastOptimalOutcomes)
        this.maxRegret = this.maxUtility - this.minUtility
        this.voters = voters
        this.candidates = candidates

        var candidateOutcomes = candidates.map(function(candidate) {
            return  findSocietalOptionsOutcomes([{weight:1, preferences:candidate}])
        })
        // the utility each voter would get if each candidate were elected dictator
        this.voterCandidateUtilities = voters.map(function(voter) {
            return candidateOutcomes.map(function(outcomes) {
                return  voterOutcomeUtility(voter, outcomes)
            })
        })
    }

    // returns an array of winning candidates represented by objects that have the properties:
        // weight - That winner's voting weight in the legislature
        // utilities - That winner's option utilities (in the same form as returned by generatePerson)
    // algorithm(votes, candidates) - A function that should return the winning candidates in the same form as this.elect returns
    // strategy(voter, candidates) - A function that should return the given voter's vote in whatever form that algorithm requires
    this.elect = function(algorithm, strategy, voters, candidates) {
        var votes = voters.map(function(voter, index) {
            return strategy(voter, index, this)
        }.bind(this))

        var results = algorithm(votes, candidates)

        results.forEach(function(winner) {
            if(winner.weight < 0) throw new Error("Winner weight can't be less than 0")
        })

        return results
    }

    // returns a number from 0 to 1 indicating what percentage of the maximum possible voter regret the deciders cause
    this.regretFraction = function(people, deciders) {
        var outcomes = findSocietalOptionsOutcomes(deciders)
        var totalUtility = totalOutcomeUtility(people, outcomes)
        var regret = this.maxUtility - totalUtility

        return regret/this.maxRegret
    }

    function createModifier() {
        var type = Math.random()
        if(Math.random() > .5) { // multiply
            var starter = 1.05
        } else { // divide
            var starter = .95
        }

        return Math.pow(starter, Math.round(Math.random()*100))
    }

    // Returns the results of a yes/no weighted majority vote on each societal preference as an array where
    // each index indicates the societal option and the value is either true or false
    // deciders - An array of winning candidates in the same form as this.elect returns
    function findSocietalOptionsOutcomes(deciders) {
        var voteWeightTotal = 0
        var societalOptionsVotes = []
        deciders.forEach(function(person) {
            voteWeightTotal += person.weight
            person.preferences.forEach(function(preference, index) {
                if(societalOptionsVotes[index] === undefined) {
                    societalOptionsVotes[index] = 0
                }

                if(preference > 0) {
                    societalOptionsVotes[index] += person.weight
                }
            })
        })

        return societalOptionsVotes.map(function(votesForOneSocietalOption) {
            return votesForOneSocietalOption/voteWeightTotal > .5
        })
    }

    // returns the total utility change for the given people if the given outcomes happened
    function totalOutcomeUtility(people, outcomes) {
        var utility = 0
        people.forEach(function(person) {
            utility += voterOutcomeUtility(person, outcomes)
        })

        return utility
    }

    function voterOutcomeUtility(voter, outcomes) {
        var totalUtility =  0
        voter.forEach(function(utility,index) {
            if(outcomes[index])
                totalUtility += utility
        })

        return totalUtility
    }

    // returns an array where the index indicates a societal option and the value indicates
    // the net utility for that option for the people passed in
    function findNetUtilities(people) {
        var netUtility = []
        people.forEach(function(person) {
            person.forEach(function(optionUtility, index) {
                if(netUtility[index] === undefined) {
                    netUtility[index] = 0
                }

                netUtility[index] += optionUtility
            })
        })

        return netUtility
    }

    // Returns an array where each element is a number from -1 to 1 indicating the utility that person would get
    // from a given societal option (identified by the index)
    function generatePerson(numberOfSocietalOptions, optionPopularityModifiers) {
        var voter = []
        for(var n=0;n<numberOfSocietalOptions;n++) {
            if(optionPopularityModifiers) {
                modifier = optionPopularityModifiers[n]
            } else {
                modifier = 1
            }

            voter[n] = 2*random()*modifier-1
        }

        return voter
    }
})


// The name of an election run with a particular system and strategy
function getVotingTypeName(systemName,strategyName, algorithmName) {
    if(strategyName === 'noname') {
        return systemName
    } else {
        return '<span style="color:rgb(0,50,150)">'+systemName+'</span> '+algorithmName+' '+strategyName
    }
}

// random number between 0 and 1 (just like Math.random)
function random() {
    var randomInteger = getRandomInt(0,255)
    return randomInteger/255
}

function getRandomInt(min, max) {
    // Create byte array and fill with 1 random number
    var byteArray = new Uint8Array(1);
    window.crypto.getRandomValues(byteArray);

    var range = max - min + 1;
    var max_range = 256;
    if (byteArray[0] >= Math.floor(max_range / range) * range)
        return getRandomInt(min, max);
    return min + (byteArray[0] % range);
}

main()

</script>

<noscript>
  <p>JavaScript is NOT enabled on your browser!</p>
</noscript>

</body>
</html>

